using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class GameController : MonoBehaviour
{
    [SerializeField] Deck deck;
    [SerializeField] Deck enemyDeck;
    [SerializeField] EnemyUI enemyUI;
    [SerializeField] Player player;
    [SerializeField] Player enemyPlayer;
    [SerializeField] GameObject noactionCurtain;
    [SerializeField] GameObject gameMessage;
    [SerializeField] ResultDisplay resultDisplay;
    [SerializeField] private LoadingManager loadingManager;
    [SerializeField] private SoundManager soundManager;
    [SerializeField] public CountdownTimer countdownTimer;

    [SerializeField] PlayerHandController playerHandController;
    [SerializeField] PlayerHandController enemyHandController;

    [SerializeField] TextMeshProUGUI playerActionText;
    [SerializeField] TextMeshProUGUI gameMessageText;


    public bool canPlayerAction;
    public bool canEnemyAction;
    public bool canPlayNow;
    public bool endGameFlg;

    private const int GAME_TIMELIMIT = 99;//ゲームの制限時間
    private const float READY_TIME = 3.0f;//試合開始するまでの待ち時間
    private const float MESSAGE_DISPTIME_MIN = 0.5f;//メッセージが表示される最小時間


    void Start()
    {
        StartCoroutine(StartGame());
    }

    //0.5秒ごとに実行する。
    void FixedUpdate()
    {
        StartCoroutine(JudgePlaying());
    }

    /// <summary>
    /// ゲーム開始時に実行される処理。山札生成、手札生成、ゲーム開始を支持する。
    /// </summary>
    /// <returns></returns>
    public IEnumerator StartGame()
    {
        soundManager.PlayBgmBattle();
        countdownTimer.SetTimer(GAME_TIMELIMIT, LimitTimer);
        yield return StartCoroutine(LoadGame());
        yield return StartCoroutine(loadingManager.EndLoad());

        gameMessage.SetActive(true);
        gameMessageText.text = @$"READY...";
        
        //手札生成処理
        StartCoroutine(ReadyPlayer());
        StartCoroutine(ReadyEnemy());
        yield return new WaitForSeconds(READY_TIME);

        gameMessageText.text = @$"START!!";
        yield return new WaitForSeconds(MESSAGE_DISPTIME_MIN);

        //場札生成処理
        StartCoroutine(deck.MakeField(0));
        StartCoroutine(enemyDeck.MakeField(1));
        soundManager.PlaySpeed();
        canPlayNow = true;
        StartCoroutine(countdownTimer.CountDown());
        noactionCurtain.SetActive(false);
        gameMessage.SetActive(false);
        StartCoroutine(enemyUI.ActionEnemy());
        gameMessageText.text = @$"";
    }

    public void PauseGamePlaying()
    {
        canPlayNow = false;
        noactionCurtain.SetActive(true);
    }

    public void ReStartGamePlaying()
    {
        canPlayNow = true;
        noactionCurtain.SetActive(false);
    }


    private IEnumerator ReadyPlayer()
    {
        yield return StartCoroutine(deck.MakePlayerDeck());
        yield return StartCoroutine(playerHandController.MakePlayerHand());  
    }

    private IEnumerator ReadyEnemy()
    {
        yield return StartCoroutine(enemyDeck.MakePlayerDeck());
        yield return StartCoroutine(enemyHandController.MakePlayerHand());
    }


    /// <summary>
    /// プレイ可能中に以下を判定する。「ゲーム終了条件」「プレイヤーの行動可否」「SP発動可能可否」「仕切り直し実行可否」
    /// </summary>
    private IEnumerator JudgePlaying()
    {
        Debug.Log("ジャッジ処理");
        if (canPlayNow == true)
        {
            JudgeBothPlayerHp();
            yield return StartCoroutine(CheckPlayerCanAction());

            if (canPlayerAction == false)
            {
                playerActionText.text = @$"出せるカードがありません。";
            }
            else
            {
                playerActionText.text = @$""; ;
            }

            if (player.canDoSpecial == true)
            {
                playerActionText.text = @$"S.Pゲージが満タンです。山札タッチでS.P発動";
            }

            if (canPlayerAction == false && canEnemyAction == false)
            {
                Debug.Log("スピード処理");
                canPlayNow = false;
                yield return StartCoroutine(Speed());
            }
        }
    }

    private IEnumerator CheckPlayerCanAction()
    {
        canPlayerAction = playerHandController.CheckCanAction();
        canEnemyAction = enemyHandController.CheckCanAction();
        yield return null;
    }

    /// <summary>
    /// 両プレイヤーが場札にカードを置けない場合、両プレイヤーの山札から場札に1枚ずつカードを置く。
    /// ゲーム内では『仕切り直し【スピード】と呼ぶ。』
    /// </summary>
    public IEnumerator Speed()
    {
        Debug.Log("スピード");
        yield return new WaitForSeconds(1.0f);
        soundManager.PlayWhistle();
        PauseGamePlaying();
        gameMessage.SetActive(true);
        gameMessageText.text = @$"仕切り直し";
        playerActionText.text = @$"場札をリセットします。";
        yield return new WaitForSeconds(1.0f);

        gameMessageText.text = @$"スピー　 ";
        soundManager.PlayVoiceSPEE();
        yield return new WaitForSeconds(1.0f);

        gameMessageText.text = @$"スピード!";
        soundManager.PlayVoiceDO();
        yield return new WaitForSeconds(MESSAGE_DISPTIME_MIN);
        
        soundManager.PlaySpeed();
        StartCoroutine(deck.MakeField(0));
        StartCoroutine(enemyDeck.MakeField(1));
        gameMessage.SetActive(false);
        gameMessageText.text = @$"";
        ReStartGamePlaying();
        player.CheckSpeedTriggerSkill();
        enemyPlayer.CheckSpeedTriggerSkill();
        yield return null;
    }

    /// <summary>
    /// どちらかのプレイヤーのHPが0以下になるとゲームを終了する。
    /// </summary>
    public void JudgeBothPlayerHp()
    {
        if(player.nowHp <= 0 || enemyPlayer.nowHp <= 0)
        {
            EndGame();
            if (player.nowHp <= 0)
            {
                string winner = "2P PLAYER";
                StartCoroutine(resultDisplay.Ready(enemyPlayer,winner));
            }else if (enemyPlayer.nowHp <= 0)
            {
                string winner = "1P PLAYER";
                StartCoroutine(resultDisplay.Ready(player,winner));
            }
            
        }
    }

    //制限時間を過ぎたときの処理。HPが高いほうが勝者になる。
    public void LimitTimer()
    {
        EndGame();
        if (player.nowHp >= enemyPlayer.nowHp)
        {
            string winner = "1P PLAYER";
            StartCoroutine(resultDisplay.Ready(player, winner)); 
        }
        else if (player.nowHp < enemyPlayer.nowHp)
        {
            string winner = "2P PLAYER";
            StartCoroutine(resultDisplay.Ready(enemyPlayer, winner));
        }
    }

    private IEnumerator LoadGame()
    {
        yield return StartCoroutine(PassCharacterData());
        yield return StartCoroutine(player.ReadyGame());
        yield return StartCoroutine(enemyPlayer.ReadyGame());
    }

    /// <summary>
    /// ゲーム終了時にリザルト画面を表示させる処理。
    /// </summary>
    private void EndGame()
    {
        canPlayNow = false;
        endGameFlg = true;
        noactionCurtain.SetActive(true);
        gameMessage.SetActive(true);
        gameMessageText.text = @$"GAME SET!!";
        soundManager.PlayWhistle();
    }

    /// <summary>
    /// 選択画面で選択したキャラクターをプレイヤーオブジェクトに渡す。両方にデータが入っていない場合は、
    /// 予めアタッチされていたキャラクターデータをそのまま読み込む。
    /// </summary>
    private IEnumerator PassCharacterData()
    {
        if (SelectController.playerCharacterData != null && SelectController.enemyCharacterData != null)
        {
            player.characterData = SelectController.playerCharacterData;
            enemyPlayer.characterData = SelectController.enemyCharacterData;
        }
        yield return null;
    }

}
